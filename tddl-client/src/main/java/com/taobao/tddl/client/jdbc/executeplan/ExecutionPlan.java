package com.taobao.tddl.client.jdbc.executeplan;

import java.util.List;
import java.util.Map;

import com.taobao.tddl.client.dispatcher.LogicTableName;
import com.taobao.tddl.client.jdbc.RealSqlContext;
import com.taobao.tddl.client.jdbc.SqlExecuteEvent;
import com.taobao.tddl.common.jdbc.ParameterContext;
import com.taobao.tddl.sqlobjecttree.GroupFunctionType;
import com.taobao.tddl.sqlobjecttree.OrderByEle;

/**
 * 这个接口是sql执行器执行sql的依据。
 * 
 * 包含了sql执行的一些基本的信息。
 * 
 * @author shenxun
 *
 */
public interface ExecutionPlan {
	/**
	 * 
	 * @return 非空
	 */
	Map<String/*db Selector id */, List<RealSqlContext>/*真正在当前database上执行的sql的列表*/> getSqlMap(); 
	/**
	 * 获取order by 信息
	 * @return
	 */
	public List<OrderByEle> getOrderByColumns() ;
	/**
	 * 获取skip值
	 * @return
	 */
	public int getSkip();
	/**
	 * 获取max的值
	 * @return
	 */
	public int getMax() ;
	
	/**
	 * 获取数据复制所需要的信息
	 * 
	 * @return
	 */
	public List<SqlExecuteEvent> getEvents() ;
	
	/**
	 * 获取group function
	 * @return
	 */
	public GroupFunctionType getGroupFunctionType();
	
	/**
	 * 获取虚拟表名
	 * @return
	 */
	public LogicTableName getVirtualTableName();
	
	/**
	 *  是否返回mappingRule
	 *  
	 * @return
	 */
	public boolean mappingRuleReturnNullValue();
	
	/**
	 * 是否走从库进行读写。
	 * 
	 * @return
	 */
	public boolean isGoSlave();
	
	public String getOriginalSql();
	
	public Map<Integer, ParameterContext> getOriginalArgs();
	/**
	 * 如果是只针对一个连接，只执行一条sql的场景下，走最简单的直接使用原有Statement的模式
	 * 
	 * @return true 如果使用简单模式
	 */
	public boolean isUsingRealConnection();
	
	public boolean isUseParallel();
	
	public int getAutoGeneratedKeys();

	public void setAutoGeneratedKeys(int autoGeneratedKeys) ;

	public int[] getColumnIndexes() ;

	public void setColumnIndexes(int[] columnIndexes);
	
	public String[] getColumnNames();

	public void setColumnNames(String[] columnNames);
	
	public List<String> getDistinctColumns() ;

	public void setDistinctColumns(List<String> distinctColumns) ;
}
